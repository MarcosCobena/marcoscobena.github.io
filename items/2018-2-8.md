During Christmas I was working on a small game prototype, fully backed by the
joy I had going through Thimbleweed Park. Basically enabled a way to write down
state-based logic in a ViewModel, which informs the View on just a few messages
where this last only reacts. Everything powered by Tasks.

Today I woke up thinking could do better with the screen am on currently, and
decided to implement that of above. Iâ€™m super lucky of being sat down ten steps
away from Dani CÃ¡ceres, the one I know in person who better manages Tasks in
depth.

And asked him to review my code. And, obviously, had stuff to improve. The most
significantâ€™s a corner case where a Task could be there forever, so he
introduced `CancellationToken.Register()`: a straight way to dispose stuff when
the cancellation happens, and fit perfectly in my scenario.

Thanks Dani! ğŸ™‚

Back to the logic, my VM know exposes the following:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Â Â Â Â publicÂ asyncÂ TaskÂ StartStateMachineAsync()
Â Â Â Â {
Â Â Â Â Â Â Â Â ifÂ (_cancellationTokenSourceÂ !=Â nullÂ &&Â !_cancellationTokenSource.IsCancellationRequested)
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â return;
Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â _cancellationTokenSourceÂ =Â newÂ CancellationTokenSource();
Â Â Â Â Â Â Â Â varÂ tokenÂ =Â _cancellationTokenSource.Token;

Â Â Â Â Â Â Â Â whileÂ (!token.IsCancellationRequested)
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â MessagingCenter.Send(this,Â NFCUnavailableMessage);
Â Â Â Â Â Â Â Â Â Â Â Â awaitÂ Task.Delay(SecondsToHoldBetweenStates);

Â Â Â Â Â Â Â Â Â Â Â Â varÂ isNFCSupportedÂ =Â CheckNFCSupport();

Â Â Â Â Â Â Â Â Â Â Â Â ifÂ (isNFCSupported)
Â Â Â Â Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â awaitÂ PoolForNFCAvailableAsync();
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â else
Â Â Â Â Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â continue;
Â Â Â Â Â Â Â Â Â Â Â Â }

Â Â Â Â Â Â Â Â Â Â Â Â MessagingCenter.Send(this,Â ReadyToReadMessage);
Â Â Â Â Â Â Â Â Â Â Â Â awaitÂ Task.Delay(SecondsToHoldBetweenStates);

Â Â Â Â Â Â Â Â Â Â Â Â varÂ nfcTagIdÂ =Â awaitÂ TagDetectedAsync(_cancellationTokenSource.Token);

Â Â Â Â Â Â Â Â Â Â Â Â MessagingCenter.Send(this,Â ReadSuccessfulMessage);
Â Â Â Â Â Â Â Â Â Â Â Â awaitÂ Task.Delay(SecondsToHoldBetweenStates);

Â Â Â Â Â Â Â Â Â Â Â Â awaitÂ TryNavigatingToMatchingControlAsync(nfcTagId);
Â Â Â Â Â Â Â Â }
Â Â Â Â }

Â Â Â Â publicÂ voidÂ StopStateMachine()
Â Â Â Â {
Â Â Â Â Â Â Â Â _cancellationTokenSource.Cancel();
Â Â Â Â }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

(Yes, itâ€™s all about handling NFC detection triggering some anims. in UI.)

Every piece of logic in on the VM. *Every*. Thisâ€™ the View:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Â Â Â Â protectedÂ overrideÂ voidÂ OnAppearing()
Â Â Â Â {
Â Â Â Â Â Â Â Â base.OnAppearing();

Â Â Â Â Â Â Â Â SubscribeMessages();
Â Â Â Â Â Â Â Â ViewModel.StartStateMachineAsync().ConfigureAwait(false);
Â Â Â Â }

Â Â Â Â protectedÂ overrideÂ voidÂ OnDisappearing()
Â Â Â Â {
Â Â Â Â Â Â Â Â base.OnDisappearing();

Â Â Â Â Â Â Â Â ifÂ (!_isAndroidMainActivityPausedBecauseOfNFCDetection)
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â UnsubscribeMessages();
Â Â Â Â Â Â Â Â Â Â Â Â ViewModel.StopStateMachine();
Â Â Â Â Â Â Â Â Â Â Â Â ResetImagesToTheirInitialState();
Â Â Â Â Â Â Â Â }
Â Â Â Â }

Â Â Â Â privateÂ voidÂ ResetImagesToTheirInitialState()
Â Â Â Â {
Â Â Â Â Â Â Â Â nfcUnavailableImage.OpacityÂ =Â 0.12f;
Â Â Â Â Â Â Â Â nfcReadyImage.OpacityÂ =Â 0;
Â Â Â Â Â Â Â Â nfcJustNFCImage.OpacityÂ =Â 0;
Â Â Â Â Â Â Â Â nfcJustOKImage.OpacityÂ =Â 0;
Â Â Â Â }

Â Â Â Â privateÂ voidÂ SubscribeMessages()
Â Â Â Â {
Â Â Â Â Â Â Â Â MessagingCenter.Subscribe<NFCViewModel>(this,Â NFCViewModel.NFCUnavailableMessage,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â asyncÂ _Â =>
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â awaitÂ nfcReadyImage.FadeTo(0);
Â Â Â Â Â Â Â Â Â Â Â Â nfcJustNFCImage.ScaleÂ =Â 1;
Â Â Â Â Â Â Â Â Â Â Â Â nfcJustOKImage.ScaleÂ =Â 0;
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â [...]
Â Â Â Â }
Â Â Â Â 
Â Â Â Â privateÂ voidÂ UnsubscribeMessages()
Â Â Â Â {
Â Â Â Â Â Â Â Â MessagingCenter.Unsubscribe<NFCViewModel>(this,Â NFCViewModel.NFCUnavailableMessage);
Â Â Â Â Â Â Â Â [...]
Â Â Â Â }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Thatâ€™s all. Probably thisâ€™ so obvious for you, or discover loads of downsides.
Whatever it comes to your mind, please share it. For me itâ€™s like got something
really interesting to supply with MVVM, but itâ€™s â€œmy sonâ€.
